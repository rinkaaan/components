{"version":3,"file":"extractor.js","sourceRoot":"","sources":["../../src/components/extractor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport ts from 'typescript';\n\nimport {\n  extractDeclaration,\n  getDescription,\n  isOptional,\n  stringifyType,\n  unwrapNamespaceDeclaration,\n} from '../shared/type-utils';\n\nexport interface ExtractedDescription {\n  text: string | undefined;\n  tags: Array<{ name: string; text: string | undefined }>;\n}\n\nexport interface ExpandedProp {\n  name: string;\n  type: string;\n  isOptional: boolean;\n  rawType: ts.Type;\n  rawTypeNode: ts.TypeNode | undefined;\n  description: ExtractedDescription;\n}\n\nexport function extractDefaultValues(exportSymbol: ts.Symbol, checker: ts.TypeChecker) {\n  let declaration: ts.Node = extractDeclaration(exportSymbol);\n  if (ts.isExportAssignment(declaration)) {\n    // Traverse from \"export default Something;\" to the actual \"Something\"\n    const symbol = checker.getSymbolAtLocation(declaration.expression);\n    if (!symbol) {\n      throw new Error('Cannot resolve symbol');\n    }\n    declaration = extractDeclaration(symbol);\n  }\n  // Extract \"Something\" from \"const Component = Something\"\n  if (ts.isVariableDeclaration(declaration) && declaration.initializer) {\n    declaration = declaration.initializer;\n  }\n  // Extract \"Something\" from \"Something as MyComponentType\"\n  if (ts.isAsExpression(declaration)) {\n    declaration = declaration.expression;\n  }\n  // Extract \"Something from React.forwardRef(Something)\"\n  if (\n    ts.isCallExpression(declaration) &&\n    (declaration.expression.getText() === 'React.forwardRef' || declaration.expression.getText() === 'forwardRef')\n  ) {\n    declaration = declaration.arguments[0];\n  }\n\n  // In the component function, find arguments destructuring\n  let argument: ts.Node | undefined;\n  if (\n    ts.isFunctionDeclaration(declaration) ||\n    ts.isFunctionExpression(declaration) ||\n    ts.isArrowFunction(declaration)\n  ) {\n    if (declaration.parameters.length === 0) {\n      return {};\n    }\n    argument = declaration.parameters[0].name;\n  }\n  if (!argument) {\n    throw new Error(`Unsupported component declaration type ${ts.SyntaxKind[declaration.kind]}`);\n  }\n  if (!ts.isObjectBindingPattern(argument)) {\n    // if a component does not use props de-structuring, we do not detect default values\n    return {};\n  }\n  const values: Record<string, string> = {};\n  for (const element of argument.elements) {\n    if (ts.isIdentifier(element.name) && element.initializer) {\n      values[element.name.escapedText as string] = element.initializer.getText();\n    }\n  }\n  return values;\n}\n\nexport function extractProps(propsSymbol: ts.Symbol, checker: ts.TypeChecker) {\n  const exportType = checker.getDeclaredTypeOfSymbol(propsSymbol);\n\n  return exportType\n    .getProperties()\n    .map((value): ExpandedProp => {\n      const declaration = extractDeclaration(value);\n      const type = checker.getTypeAtLocation(declaration);\n      return {\n        name: value.name,\n        type: stringifyType(type, checker),\n        rawType: type,\n        rawTypeNode: (declaration as ts.PropertyDeclaration).type,\n        isOptional: isOptional(type),\n        description: getDescription(value.getDocumentationComment(checker), declaration),\n      };\n    })\n    .sort((a, b) => a.name.localeCompare(b.name));\n}\n\nexport function extractFunctions(propsSymbol: ts.Symbol, checker: ts.TypeChecker) {\n  const propsName = propsSymbol.getName();\n  const namespaceDeclaration = [\n    // if we got the namespace directly\n    ...(propsSymbol.getDeclarations() ?? []),\n    // find namespace declaration from the interface with the same name\n    ...(checker.getDeclaredTypeOfSymbol(propsSymbol).getSymbol()?.getDeclarations() ?? []),\n  ].find(decl => decl.kind === ts.SyntaxKind.ModuleDeclaration);\n  const refType = unwrapNamespaceDeclaration(namespaceDeclaration)\n    .map(child => checker.getTypeAtLocation(child))\n    .find(type => (type.getSymbol() ?? type.aliasSymbol)?.getName() === 'Ref');\n\n  if (!refType) {\n    return [];\n  }\n  return refType\n    .getProperties()\n    .map((value): ExpandedProp => {\n      const declaration = extractDeclaration(value);\n      const type = checker.getTypeAtLocation(declaration);\n      const realType = type.getNonNullableType();\n      if (realType.getCallSignatures().length === 0) {\n        throw new Error(\n          `${propsName}.Ref should contain only methods, \"${value.name}\" has a \"${stringifyType(type, checker)}\" type`,\n        );\n      }\n      return {\n        name: value.name,\n        type: stringifyType(realType, checker),\n        rawType: realType,\n        rawTypeNode: (declaration as ts.PropertyDeclaration).type,\n        isOptional: isOptional(type),\n        description: getDescription(value.getDocumentationComment(checker), declaration),\n      };\n    })\n    .sort((a, b) => a.name.localeCompare(b.name));\n}\n\nexport function extractExports(\n  componentName: string,\n  exportSymbols: ts.Symbol[],\n  checker: ts.TypeChecker,\n  extraExports: Record<string, Array<string>>,\n) {\n  let componentSymbol;\n  let propsSymbol;\n  const unknownExports: Array<string> = [];\n  for (const exportSymbol of exportSymbols) {\n    if (exportSymbol.name === 'default') {\n      validateComponentType(componentName, exportSymbol, checker);\n      componentSymbol = exportSymbol;\n    } else if (exportSymbol.name === `${componentName}Props`) {\n      propsSymbol = exportSymbol;\n    } else if (!extraExports[componentName] || !extraExports[componentName].includes(exportSymbol.name)) {\n      unknownExports.push(exportSymbol.name);\n    }\n  }\n  if (unknownExports.length > 0) {\n    throw new Error(`Unexpected exports in ${componentName}: ${unknownExports.join(', ')}`);\n  }\n  if (!componentSymbol) {\n    throw new Error(`Missing default export for ${componentName}`);\n  }\n  if (!propsSymbol) {\n    throw new Error(`Missing ${componentName}Props export`);\n  }\n  return { componentSymbol, propsSymbol };\n}\n\nfunction validateComponentType(componentName: string, symbol: ts.Symbol, checker: ts.TypeChecker) {\n  const declaration = extractDeclaration(symbol);\n  let type: ts.Type;\n  if (ts.isExportAssignment(declaration)) {\n    // export default Something;\n    type = checker.getTypeAtLocation(declaration.expression);\n  } else if (ts.isFunctionDeclaration(declaration)) {\n    // export default function Something() {...}\n    type = checker.getTypeAtLocation(declaration);\n  } else {\n    throw new Error(`Unknown default export for ${componentName}`);\n  }\n  if (\n    // React.forwardRef\n    type.getSymbol()?.name !== 'ForwardRefExoticComponent' &&\n    // Plain function returning JSX\n    type.getCallSignatures().some(signature => {\n      const returnTypeName = checker.typeToString(signature.getReturnType());\n      return returnTypeName !== 'Element' && returnTypeName !== 'ReactPortal';\n    })\n  ) {\n    throw new Error(`Unknown default export type ${checker.typeToString(type)}`);\n  }\n}\n"]}