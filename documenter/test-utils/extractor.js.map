{"version":3,"file":"extractor.js","sourceRoot":"","sources":["../../src/test-utils/extractor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport ts from 'typescript';\nimport {\n  extractDeclaration,\n  extractTypeArguments,\n  getDescription,\n  isNullable,\n  isOptional,\n  stringifyType,\n} from '../shared/type-utils';\nimport { TestUtilsDoc } from './interfaces';\n\nfunction getInheritedFrom(declaration: ts.Declaration, currentClassName: string) {\n  if (!ts.isMethodDeclaration(declaration) || !ts.isClassDeclaration(declaration.parent) || !declaration.parent.name) {\n    throw new Error(`Unexpected declaration parent: ${declaration.getText()}`);\n  }\n  const parentName = declaration.parent.name.getText();\n  if (parentName === currentClassName) {\n    return undefined;\n  }\n  return { className: parentName, methodName: declaration.name.getText() };\n}\n\nfunction getDefaultValue(declaration: ts.Declaration) {\n  if (!ts.isParameter(declaration)) {\n    throw new Error(`Unexpected declaration: ${declaration.getText()}`);\n  }\n  if (!declaration.initializer) {\n    return undefined;\n  }\n  return declaration.initializer.getText();\n}\n\nexport default function extractDocumentation(\n  sourceFile: ts.SourceFile,\n  checker: ts.TypeChecker,\n  extraExports: Array<string>,\n  includeCoreMethods: boolean,\n): Array<TestUtilsDoc> {\n  const moduleSymbol = checker.getSymbolAtLocation(sourceFile);\n  if (!moduleSymbol) {\n    throw new Error(`Unable to resolve module: ${sourceFile.fileName}`);\n  }\n\n  const exportSymbols = checker.getExportsOfModule(moduleSymbol);\n  const definitions = new Map<string, TestUtilsDoc>();\n\n  for (const symbol of exportSymbols) {\n    const className = symbol.getName();\n    if (extraExports.includes(className)) {\n      continue;\n    }\n    const classType = checker.getDeclaredTypeOfSymbol(symbol);\n    documentClass(definitions, symbol, classType, checker, includeCoreMethods);\n  }\n\n  return Array.from(definitions.values());\n}\n\nfunction documentClass(\n  definitions: Map<string, TestUtilsDoc>,\n  symbol: ts.Symbol,\n  classType: ts.Type,\n  checker: ts.TypeChecker,\n  includeCoreMethods: boolean,\n) {\n  if (!classType.isClass()) {\n    throw new Error(`Exported symbol is not a class, got ${checker.symbolToString(symbol)}`);\n  }\n  const className = checker.symbolToString(symbol);\n  const definition: TestUtilsDoc = { name: className, methods: [] };\n  definitions.set(className, definition);\n\n  for (const property of classType.getProperties()) {\n    const declaration = property.valueDeclaration;\n    if (!declaration) {\n      throw new Error(`Unexpected member on ${className} â€“ ${property.getName()}`);\n    }\n    const modifiers = (ts.canHaveModifiers(declaration) && ts.getModifiers(declaration)) || [];\n    if (\n      modifiers.find(\n        modifier => modifier.kind === ts.SyntaxKind.ProtectedKeyword || modifier.kind === ts.SyntaxKind.PrivateKeyword,\n      )\n    ) {\n      continue;\n    }\n    const type = checker.getTypeAtLocation(declaration);\n    // report each function signature as a separate method\n    for (const signature of type.getCallSignatures()) {\n      const maybeReturnType = signature.getReturnType();\n      // non-nullable type of `void` is `never`\n      const returnType =\n        maybeReturnType.flags & ts.TypeFlags.Void ? maybeReturnType : maybeReturnType.getNonNullableType();\n      const dependency = findDependencyType(returnType, checker);\n      if (dependency && !definitions.has(dependency.typeName)) {\n        documentClass(definitions, dependency.symbol, dependency.type, checker, includeCoreMethods);\n      }\n\n      const { typeName, typeParameters } = extractTypeArguments(returnType, checker);\n\n      const inheritedFrom = getInheritedFrom(declaration, className);\n      if (\n        inheritedFrom &&\n        !includeCoreMethods &&\n        ['AbstractWrapper', 'ElementWrapper'].includes(inheritedFrom?.className)\n      ) {\n        continue;\n      }\n\n      definition.methods.push({\n        name: property.getName(),\n        description: getDescription(property.getDocumentationComment(checker), declaration).text,\n        returnType: {\n          name: typeName,\n          isNullable: isNullable(maybeReturnType),\n          typeArguments: typeParameters?.map(typeArgument => ({\n            name: stringifyType(typeArgument, checker),\n          })),\n        },\n        parameters: signature.parameters.map(parameter => {\n          const paramType = checker.getTypeAtLocation(extractDeclaration(parameter));\n          return {\n            name: parameter.name,\n            typeName: stringifyType(paramType, checker),\n            description: getDescription(parameter.getDocumentationComment(checker), declaration).text,\n            flags: { isOptional: isOptional(paramType) },\n            defaultValue: getDefaultValue(extractDeclaration(parameter)),\n          };\n        }),\n        inheritedFrom: inheritedFrom ? { name: `${inheritedFrom.className}.${inheritedFrom.methodName}` } : undefined,\n      });\n    }\n  }\n  definition.methods.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction findDependencyType(\n  type: ts.Type,\n  checker: ts.TypeChecker,\n): { typeName: string; type: ts.Type; symbol: ts.Symbol } | undefined {\n  const symbol = type.getSymbol();\n  if (!symbol) {\n    return;\n  }\n\n  const typeName = checker.symbolToString(symbol);\n  if (typeName === 'Array' || typeName === 'MultiElementWrapper') {\n    const itemType = checker.getTypeArguments(type as ts.TypeReference)[0];\n    return findDependencyType(itemType, checker);\n  }\n  if (\n    !typeName.endsWith('Wrapper') ||\n    ['ElementWrapper', 'ComponentWrapper'].includes(typeName) ||\n    !type.isClassOrInterface()\n  ) {\n    return;\n  }\n\n  return {\n    typeName,\n    type,\n    symbol,\n  };\n}\n"]}